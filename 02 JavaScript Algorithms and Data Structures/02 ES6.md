# Explore Differences Between the var and let Keywords

En el JS clásico se podía sobrescribir declaraciones de variable accidentalmente, sin que aparezca un error.

> En este caso el resultado sería "David":

```js
var camper = "James";
var camper = "David";
console.log(camper);
```

Las variables **let** de ES6 resuelven este problema.

> En este caso el resultado mostraría un error en la consola del navegador:

```js
let camper = "James";
let camper = "David";
```

## Activar modo estricto

> El código termina de ejecutarse cuando la app presenta errores en el código o acciones "inseguras. Por ejemplo en el siguiente caso, el error mostrará que **x** no está definida:

```js
"use strict";
x = 3.14;
```

## Ejercicio

Update the code so it only uses the let keyword.

```js
let catName;
let quote;
function catTalk() {
  "use strict";

  catName = "Oliver";
  quote = catName + " says Meow!";
}
catTalk();
```

# Compare Scopes of the var and let Keywords

Las viejas variables **var** poseen declaración global. Y si son creadas dentro de una función, su declaración es a nivel local.

Las variables **let** tienen algunas caracteristicas extra: se limitan solamente al bloque, sentencia o expresión donde fueron creadas.

## Ejemplo

```js
function checkScope() {
  let i = "function scope";
  if (true) {
    let i = "block scope";
    console.log("Block scope i is: ", i);
  }
  console.log("Function scope i is: ", i);
  return i;
}
```

# Declare a Read-Only Variable with the const Keyword

Las variables **const** poseen las mismas características que las variables **let** con la diferencia de que una vez asignado un valor, no se puede modificar.

Una práctica común para el nombrado de constantes es utilizar letras en mayúsculas y si son más de una palabra, separarlas con un guión bajo.

```js
function printManyTimes(str) {
  const SENTENCE = str + " is cool!";
  for (let i = 0; i < str.length; i += 2) {
    console.log(SENTENCE);
  }
}
printManyTimes("freeCodeCamp");
```

# Mutate an Array Declared with const

Si bien no se puede modificar el valor de una variable **const**, se puede modificar los valores del array asignados a una variable **const**:

```js
const s = [5, 6, 7]; // declaración
s = [1, 2, 3]; // ésto da error
s[2] = 45; // ésto está permitido; modifico el array en la posición 3
console.log(s); // el resultado es 5, 6, 45
```

# Prevent Object Mutation

# Create a JavaScript Promise

Es un objeto JavaScript que se utiliza generalmente para realizar acciones asincronas.

Cuando la tarea se completa, se puede cumplir o no la promesa.

Los promises son funciones constructor, por lo que hay que usar la palabra clave **new** para crear una.

Toma una función como argumento, con dos parámetros: resolve y reject (son métodos que determinan el resultado del promise)

> Ejemplo

```js
const makeServerRequest = new Promise((resolve, reject) => {});
```

# Use Arrow Functions to Write Concise Anonymous Functions

En JavaScript usualmente no es necesario colocarle nombre a algunas funciones, especialmente cuando le pasamos una función como argumento a otra función.

En su lugar, creamos funciones en una línea.

No es necesario colocarle nombre porque no se reutilizan en otro lado.

> Ejemplo sintaxis sin arrow:

```js
const myFunc = function () {
  const myVar = "value";
  return myVar;
};
```

En ES6, se puede escribir de otra manera

> Ejemplo sintaxis arrow function:

```js
const myFunc = () => {
  const myVar = "value";
  return myVar;
};
```

Además, cuando la función no tiene cuerpo y solo retorna un valor, la sintaxis permite omitir la palabra clave return, como así también las llaves que rodean al código. Ésto ayhuda a simplificar código.

> Ejemplo arrow function simplificada

```js
const myFunc = () => "value";
```

## Ejercicio

> Rewrite the function assigned to the variable magic which returns a new Date() to use arrow function syntax. Also, make sure nothing is defined using the keyword var.

```js
const magic = () => new Date();
```

# Use the Spread Operator to Evaluate Arrays In-Place

```js
const arr = [6, 89, 3, 45];
const maximus = Math.max(...arr);
```

# Use Destructuring Assignment to Extract Values from Objects

En ES6 Destructuring Assignment sirve para asignar valores tomados directo de un objeto.

Por ejemplo en ES5 se utiliza éste código

```js
const user = { name: "John Doe", age: 34 };

const name = user.name;
const age = user.age;
// name would have a value of the string John Doe, and age would have the number 34.
```

En ES6 sería así:

```js
const { name, age } = user;
// Again, name would have a value of the string John Doe, and age would have the number 34.
```

# Use Destructuring Assignment to Assign Variables from Objects

Destructuring también permite asignar un nuevo nombre de variable a la hora de extraer valores.

Utilizando el mismo objeto del ejemplo anterior:

```js
const user = { name: "John Doe", age: 34 };
```

Así se asigna el nuevo nombre:

```js
const { name: userName, age: userAge } = user;
```

# Use Destructuring Assignment to Assign Variables from Nested Objects

```js
// Objeto de ejemplo similar a ejercicios anteriores
const user = {
  johnDoe: {
    age: 34,
    email: "johnDoe@freeCodeCamp.com",
  },
};

// Extraer valores de las propiedades del objeto y asignarlas a variables del mismo nombre
const {
  johnDoe: { age, email },
} = user;

// Asignar propiedades de un objeto a variables de distinto nombre
const {
  johnDoe: { age: userAge, email: userEmail },
} = user;
```

# Use Destructuring Assignment to Assign Variables from Arrays

Una diferencia clave entre el spread operator y el array destructuring, es que el spread operator desempaqueta todo el contenido de un array en una lista separada por comas. Consecuentemente, no se puede tomar o elegir qué elmentos se van a asignar a una variable.

Array destructuring

```js
const [a, b] = [1, 2, 3, 4, 5, 6];
console.log(a, b);
// la consola muestra a = 1, b = 2
```

Con destructuring también se puede acceder el valor a nivel de cualquier índice del array utilizando comas:

```js
const [a, b, , , c] = [1, 2, 3, 4, 5, 6];
console.log(a, b, c);
// la consola muestra 1, 2, 5
```

# Use Destructuring Assignment with the Rest Parameter to Reassign Array Elements

Si queremos usar array destructuring para juntar el resto de elementos en un array aparte...

```js
Array.prototype.slice(); // esto es similar a la siguiente sintaxis:
```

```js
const [a, b, ...arr] = [1, 2, 3, 4, 5, 7];
console.log(a, b);
console.log(arr);
// la consola devuelve 1, 2 y [3, 4, 5, 7].
```
